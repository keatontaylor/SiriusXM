<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HLS Audio Player with Channels</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #111; color:#fff; margin:0; overflow-x:hidden; }
  button { background:#222; color:#fff; padding:12px 18px; font-size:1.1rem; font-weight:600; border-radius:10px; cursor:pointer; margin:10px auto; display:block; border:1px solid #444; box-shadow:0 2px 8px rgba(0,0,0,0.5); transition:transform .15s ease, box-shadow .15s ease, background .2s ease;}
  button:hover {background:#333; transform:scale(1.03);}
  button:active {transform:scale(.97);}
  #channelDrawer {position:fixed; top:0; left:0; transform:translateX(-100%); width:350px; height:100vh; background:#1a1a1a; box-shadow:4px 0 20px rgba(0,0,0,0.5); padding:20px; overflow-y:auto; transition:transform .35s ease; z-index:9999;}
  #channelDrawer.open {transform:translateX(0);}
  #closeDrawer {background:#333; padding:6px 10px; font-size:.9rem; border-radius:4px; cursor:pointer; float:right; margin-bottom:10px;}
  #channelGrid {display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:14px; padding-top:35px;}
  .channel-card {background:#222; border-radius:10px; padding:10px; text-align:center; display:flex; flex-direction:column; align-items:center; gap:6px; cursor:pointer; transition:transform .2s ease, box-shadow .2s ease;}
  .channel-card:hover {transform:scale(1.05); box-shadow:0 0 12px rgba(255,255,255,0.2);}
  .channel-card.server-hover:hover {background:#333;}
  .channel-card img {width:85px; height:85px; border-radius:6px; object-fit:cover; opacity:0; transition:opacity .4s ease;}
  .channel-name {font-size:.85rem; margin-top:4px; text-align:center;}
  .cng-btn {padding:4px 8px; font-size:.75rem; border-radius:6px; background:#444; color:#fff; border:none; cursor:pointer; transition:.2s;}
  .cng-btn:hover {background:#666;}
  #now-playing{text-align:center;margin-top:20px;}
  #artwork{width:250px;height:250px;border-radius:12px;object-fit:cover; box-shadow:0 0 15px rgba(0,0,0,.6);margin-bottom:12px;}
  #channelInfo{font-size:1.4rem;font-weight:700;margin-bottom:6px;}
  #songInfo{font-size:1rem;color:#ccc;}
  #player{width:300px;height:40px;margin-top:10px;}
  .hidden {display:none !important;}
</style>
</head>
<body>

<!-- Toggles -->
<button id="serverModeToggle">ðŸ›‘ Server Mode: OFF</button>
<button id="honorServerToggle">ðŸŽ› Honor Server Channel: ON</button>

<!-- Channel Drawer -->
<button id="openChannelsBtn">ðŸ“¡ Browse Channels</button>
<div id="channelDrawer">
  <div id="closeDrawer">Close âœ•</div>
  <h2>Channel List</h2>
  <div id="channelGrid"></div>
</div>

<!-- Now Playing -->
<div id="now-playing">
  <img id="artwork" src="play.png">
  <div id="channelInfo">Loadingâ€¦</div>
  <div id="songInfo"></div>
  <audio id="player" controls playsinline></audio>
</div>

<script>
const DEFAULT_ARTWORK="play.png";
const player=document.getElementById("player");
const artwork=document.getElementById("artwork");
const channelInfo=document.getElementById("channelInfo");
const songInfo=document.getElementById("songInfo");
const drawer=document.getElementById("channelDrawer");

let channels=[];
let currentChannelArtwork=DEFAULT_ARTWORK;
let currentChannelId=null;

let serverMode = false;
let honorServer = true; // default ON
const honorBtn = document.getElementById("honorServerToggle");

// Drawer
document.getElementById("openChannelsBtn").onclick = () => {
  if(serverMode || honorServer){
    alert("Cannot browse channels while server mode or honor server channels is ON");
    return;
  }
  drawer.classList.add("open");
};
document.getElementById("closeDrawer").onclick = () => drawer.classList.remove("open");

// Server Mode toggle
document.getElementById("serverModeToggle").onclick = () => {
  serverMode = !serverMode;
  document.getElementById("serverModeToggle").textContent = `ðŸ›‘ Server Mode: ${serverMode?"ON":"OFF"}`;

  if(serverMode){
    honorServer = true;
    honorBtn.classList.add("hidden");

    player.pause();
    player.classList.add("hidden");
    document.querySelectorAll(".cng-btn").forEach(b=>b.classList.remove("hidden"));
    document.querySelectorAll(".channel-card").forEach(c=>c.classList.add("server-hover"));
  } else {
    honorBtn.classList.remove("hidden");
    document.querySelectorAll(".cng-btn").forEach(b=>b.classList.add("hidden"));
    document.querySelectorAll(".channel-card").forEach(c=>c.classList.remove("server-hover"));
    player.classList.remove("hidden");
    if(currentChannelId && !honorServer){
      loadChannel(channels.find(c=>c.channelId===currentChannelId));
    }
  }
};

// Honor Server toggle (only when serverMode OFF)
honorBtn.onclick = () => {
  if(serverMode) return; 
  honorServer = !honorServer;
  honorBtn.textContent = `ðŸŽ› Honor Server Channel: ${honorServer?"ON":"OFF"}`;
};

// Send .cng
async function sendChannelChange(id){
  if(!id) return;
  try{ await fetch(`/${id}.cng`); console.log("Sent channel change â†’", id); }
  catch(e){console.error(e);}
}

// Update current song
async function updateCurrentSong(){
  if(!currentChannelId) return;
  try{
    const res = await fetch(`/${currentChannelId}.json`);
    const t = await res.json();
    const ttl = t.title||"";
    const art = t.artists?.[0]?.name||"";
    const alb = t.album?.title||"";
    const artURL = t.album?.creativeArts?.find(a=>a.size==="MEDIUM")?.url || currentChannelArtwork;

    // Show channel + song info
    const chName = channels.find(c=>c.channelId===currentChannelId)?.name || "";
    channelInfo.textContent = `${currentChannelId} - ${chName}`;
    songInfo.textContent = `${ttl} - ${art}`;

    artwork.src = artURL;
    if('mediaSession' in navigator)
      navigator.mediaSession.metadata = new MediaMetadata({title:ttl, artist:art, album:alb, artwork:[{src:artURL}]});
  }catch(e){console.error(e);}
}

// Load channels
async function loadChannels(){
  try{
    const res = await fetch("/channels.m3u");
    const lines = (await res.text()).split(/\r?\n/);
    channels = [];

    for(let i=0;i<lines.length;i++){
      if(lines[i].startsWith("#EXTINF:")){
        const displayName = lines[i].split(",")[1]?.trim()||"Unknown";
        const channelIdMatch = lines[i].match(/tvg-id="([^"]+)"/);
        const channelId = channelIdMatch ? channelIdMatch[1] : displayName.replace(/\s+/g,"_").toLowerCase();
        const url = lines[i+1]?.trim();
        if(!url) continue;
        const logoMatch = lines[i].match(/tvg-logo="([^"]+)"/);
        let logo=currentChannelArtwork;
        if(logoMatch){
          const original = logoMatch[1];
          logo=(location.protocol==="https:" && original.startsWith("http://")) ? `/proxy/${encodeURIComponent(original)}` : original;
        }
        channels.push({name:displayName,url,logo,channelId});
      }
    }

    const grid=document.getElementById("channelGrid");
    grid.innerHTML="";

    channels.forEach(ch=>{
      const card = document.createElement("div");
      card.className="channel-card";
      card.innerHTML = `<img data-logo="${ch.logo}" alt="logo"><div class="channel-name">${ch.name}</div><button class="cng-btn ${serverMode?'':'hidden'}">Send to Web Players</button>`;

      card.addEventListener("click", ()=>{ 
        if(serverMode){
          sendChannelChange(ch.channelId);
          currentChannelId = ch.channelId;
          currentChannelArtwork = ch.logo;
          artwork.src = ch.logo;
          channelInfo.textContent = `${ch.channelId} - ${ch.name}`;
          songInfo.textContent = "";
        } else {
          loadChannel(ch);
        }
        drawer.classList.remove("open"); 
      });

      card.querySelector(".cng-btn").addEventListener("click", e=>{
        e.stopPropagation();
        sendChannelChange(ch.channelId);
        if(serverMode){
          currentChannelId = ch.channelId;
          currentChannelArtwork = ch.logo;
          artwork.src = ch.logo;
          channelInfo.textContent = `${ch.channelId} - ${ch.name}`;
          songInfo.textContent = "";
        }
      });

      grid.appendChild(card);
    });

    setupLazyLoading();
    if(channels.length && !serverMode) loadChannel(channels[0]);

  }catch(e){console.error(e);}
}

// Lazy load images
function setupLazyLoading(){
  const imgs=document.querySelectorAll('#channelGrid img[data-logo]');
  const observer=new IntersectionObserver(entries=>{
    entries.forEach(entry=>{
      if(entry.isIntersecting){
        const img=entry.target;
        img.src=img.dataset.logo;
        img.onload=()=>img.style.opacity=1;
        img.removeAttribute("data-logo");
        observer.unobserve(img);
      }
    });
  },{root:drawer,rootMargin:"120px"});
  imgs.forEach(img=>observer.observe(img));
}

// Load channel (respects server mode)
function loadChannel(ch){
  currentChannelArtwork = ch.logo;
  currentChannelId = ch.channelId;

  channelInfo.textContent = `${ch.channelId} - ${ch.name}`;
  songInfo.textContent = "";

  if(!serverMode){
    player.src = ch.url;
    player.play().catch(()=>{});
  }
  artwork.src = ch.logo;
}

// Poll /current.chn
async function pollForcedChannel(){
  if(!honorServer) return;
  try{
    const r=await fetch("/current.chn");
    const forced=(await r.text()).trim();
    if(forced && forced!==currentChannelId){
      const f=channels.find(c=>c.channelId===forced);
      if(f){
        loadChannel(f);      
        updateCurrentSong();  
      }
    }
  }catch(e){}
}

loadChannels();
setInterval(updateCurrentSong,3000);
setInterval(pollForcedChannel,5000);
updateCurrentSong();
pollForcedChannel();
</script>

</body>
</html>
